import pandas as pd
from limepy.wrangle import Survey
from lxml.html import fromstring
from lxml.html.clean import Cleaner


class SurveyProcessor(object):
    """
    A general class to process Lime Survey surveys and bring them into a nice format for analyses.
    """

    def __init__(self, survey):
        """
        Initialization
        :param Survey survey: An object holding the survey to be processed.
        """
        self.survey = survey

    def filter_completed_questions(self, data_df, lastpage=39):
        """
        Function to keep only the data of completed surveys
        :param DataFrame data_df: pandas DF that contains the survey response data
        :param int lastpage: int that specifies what the last question in the survey is (in our it is 39,
                therefor the default value)
        :return DataFrame: A dataframe that contains only the completed results
        """

        # create a boolean mask to check whether the
        is_completed = data_df['lastpage'] == lastpage

        # use the boolean mask to filter the relevant rows in the dataframe
        return data_df[is_completed]

    def clean_question_text(self, text):
        """
        Function to remove all the javascript and formatting from the question text
        :param str text: Text to be cleaned from formatting.
        :return str result: Cleaned text.
        """
        cleaner = Cleaner(
            comments=True,  # True = remove comments
            meta=True,  # True = remove meta tags
            scripts=True,  # True = remove script tags
            embedded=True,  # True = remove embeded tags
        )
        clean_dom = cleaner.clean_html(text)
        cleaner_text = fromstring(clean_dom).text_content()

        # now remove all the \x\n etc. from text
        result = cleaner_text.replace('\n', ' ').replace('\xa0', ' ')
        return result

    def create_question_overview_df(self):
        """
        Method to create a dataframe that holds a mapping from every question code to
        the corresponding question text and type
        :return DataFrame: Mapping
        """

        questions = self.survey.questions

        # create an empty lists to append the columns to
        all_answer_columns = []
        all_question_names = []
        all_question_types = []
        all_question_indices = []

        # iterate over all questions, q holds the question ID in form of '1', '2', ...
        for q in questions:

            question_code = questions[q]['title']
            question_text = self.clean_question_text(questions[q]['question'])
            question_type = questions[q]['question_type']
            question_index = questions[q]['qid']

            # Process questions according to their type.
            if question_type == "Multiple choice" or question_type == "Multiple choice with comments" or question_type == "Array":
                # iterate over all subquestions (by the format of limepy, the subquestions section always has key '0')
                for s in questions[q]['subquestions']['0']:
                    sub_question_code = (s['title'])
                    sub_question_text = self.clean_question_text(s['question'])

                    merged_code = question_code + "[" + sub_question_code + "]"
                    merged_text = question_text + " - " + sub_question_text
                    all_answer_columns.append(merged_code)
                    all_question_names.append(merged_text)
                    all_question_types.append(question_type)
                    all_question_indices.append(question_index)

            # in Rankin the naming of the "subquestions" is slightly different and called "answer"
            elif question_type == "Ranking":
                # iterate over all possible answers (by the format of limepy,
                # the subquestions section always has key '0')
                for s in questions[q]['answers']['0']:
                    sub_question_code = (s['sortorder'])
                    sub_question_text = self.clean_question_text(s['answer'])

                    merged_code = question_code + "[" + sub_question_code + "]"
                    merged_text = question_text + " - " + sub_question_text
                    all_answer_columns.append(merged_code)
                    all_question_names.append(merged_text)
                    all_question_types.append(question_type)
                    all_question_indices.append(question_index)

            # there is no subtype to be handled, like in normal text
            # and the data can be appended directly
            else:
                all_answer_columns.append(question_code)
                all_question_names.append(question_text)
                all_question_types.append(question_type)
                all_question_indices.append(question_index)

        # Make the dataframe with the Question code as a header and text and type as rows
        survey_answers_df = pd.DataFrame(list(zip(all_question_names, all_question_types, all_question_indices)),
                                         index=all_answer_columns,
                                         columns=['Question', 'Question Type', 'Lime Index']).T

        return survey_answers_df

    def convert_questions_to_df(self):
        """
         This creates "the database scheme" for the survey I made up.
         It has 2 indices, the upper index is the question code as it falls out of Lime Survey (e.g. DEM1)
         The second index refers to specific formats for the question.
         We would like to have several formats (machine readable: int that can be read out
         and put into libraries like seaborn directly, answer code: like it falls out of the survey, and
         answer text, which is the according long text for the answer. This fastens the lookup for machine
         readable and generated results to the real world-answers.
         :return Dataframe: Empty dataframe that has a multi-index structure according to the survey
         """

        questions = self.survey.questions

        # collect all dataframes; for every (sub)question a 2-index dataframe is created
        # so that they can be merged at the end
        frames = []

        # iterate over all questions and treat them according to the question type
        for q in questions:
            question_code = questions[q]['title']
            question_text = self.clean_question_text(questions[q]['question'])
            question_type = questions[q]['question_type']

            # if there is only one element to select (List radio or (List dropdown)
            # create 3 columns: one for machine readable code (e.g. 1,..,n), one for answer code (e.g. A1,...An)
            # and one for long text answer
            if question_type == "List radio" or question_type == "List dropdown":

                second_level_index = ["a_code", "a_text", "a"]
                header = pd.MultiIndex.from_product([[question_code],
                                                     second_level_index], names=['code', 'version'])

                df = pd.DataFrame(columns=header)

                # append the new cdataframe
                frames.append(df)

            # for Multiple choice questions append two columns per answer.
            # a machine readable one (0/1 for no or yes) and one with the text of this subquestion
            # the text field is not really necessary, however, it helps to have it in the row
            # so we can extract it more easily during analyses
            elif question_type == "Multiple choice":

                # iterate over all subquestions (by the format of limepy, the subquestions section always has key '0')
                for s in questions[q]['subquestions']['0']:
                    sub_question_code = (s['title'])
                    merged_code = question_code + "[" + sub_question_code + "]"

                    second_level_index = ["a_text", "a"]
                    header = pd.MultiIndex.from_product([[merged_code],
                                                         second_level_index], names=['code', 'version'])
                    df = pd.DataFrame(columns=header)

                    # append the new cdataframe
                    frames.append(df)

            # if there is only one element to select (List radio or (List dropdown) + a comment
            # create 4 columns: the 3 from list + an additional one for the comment
            elif question_type == "List with comment":

                second_level_index = ["a_code", "a_text", "a", question_code + "[comment]"]
                header = pd.MultiIndex.from_product([[question_code],
                                                     second_level_index],
                                                    names=['code', 'version'])

                df = pd.DataFrame(columns=header)

                # append the new cdataframe
                frames.append(df)

            # for Multiple choice questions append three columns per answer.
            # like Multiple choice + comment field
            elif questions[q]['question_type'] == "Multiple choice with comments":

                # iterate over all subquestions (by the format of limepy, the subquestions section always has key '0')
                for s in questions[q]['subquestions']['0']:
                    sub_question_code = (s['title'])
                    merged_code = question_code + "[" + sub_question_code + "]"

                    second_level_index = ["a_text", "a", question_code + "[" + sub_question_code + "comment]"]
                    header = pd.MultiIndex.from_product([[merged_code],
                                                         second_level_index], names=['code', 'version'])
                    df = pd.DataFrame(columns=header)

                    # append the new cdataframe
                    frames.append(df)

            # here we need 2 columns per possible answer (like multiple choice).
            # One that contains the text.
            # a second one that should be machine readable:
            # Results of the participants are entered with integers. 1 shows highest priority, n lowest,
            # 0 shows that it was not selected by the participant
            elif questions[q]['question_type'] == "Ranking":

                # iterate over all answers (by the format of limepy, the answers section always has key '0')
                for a in questions[q]['answers']['0']:
                    answer_code = a['sortorder']
                    merged_code = question_code + "[" + answer_code + "]"

                    second_level_index = ["a", "a_text"]
                    header = pd.MultiIndex.from_product([[merged_code],
                                                         second_level_index],
                                                        names=['code', 'version'])
                    df = pd.DataFrame(columns=header)

                    # append the new cdataframe
                    frames.append(df)

            # each question in the array is to be treated like a normal list radio question and should therefore
            # receive 3 columns
            elif questions[q]['question_type'] == "Array":

                second_level_index = ["a_code", "a_text", "a"]

                # iterate over all subquestions (by the format of limepy, the subquestions section always has key '0')
                for s in questions[q]['subquestions']['0']:
                    sub_question_code = (s['title'])  # subquestion code
                    merged_code = question_code + "[" + sub_question_code + "]"  # bring the codes together

                    header = pd.MultiIndex.from_product([[merged_code],
                                                         second_level_index], names=['code', 'version'])

                    df = pd.DataFrame(columns=header)

                    # append the new cdataframe
                    frames.append(df)

            # one column for the free text
            elif questions[q]['question_type'] == "Long free text" or questions[q]['question_type'] == "Short free text":

                second_level_index = ["a"]
                header = pd.MultiIndex.from_product([[question_code],
                                                     second_level_index], names=['code', 'version'])

                df = pd.DataFrame(columns=header)

                # append the new dataframe
                frames.append(df)

            # Case for questions of which the type is not listed
            else:
                print("error, type not known ", questions[q]['question_type'])

        # create an empty dataframe from all the individual ones
        result = pd.concat(frames)
        return result

class MLSurveyProcessor(SurveyProcessor):
    """
    Here we have a class for a concrete survey we are running.
    The "database" scheme is adapted according to the real survey data.
    Therefore, it uses the general structure + extra fields
    """

    def convert_questions_to_df(self):

        # get the general structure
        result = super().convert_questions_to_df()

        # and add the concrete fields we need
        # the metadata columns (from the front)
        result.insert(0, "submitdate", [])
        result.insert(0, "lastpage", [])
        result.insert(0, "startlanguage", [])
        result.insert(0, "seed", [])
        result.insert(0, "startdate", [])
        result.insert(0, "datestamp", [])
        result.insert(0, "id", [])

        # now add the 'other' fields to
        result.insert(0, ('AWA2', 'AWA2[other]'), [])
        result.insert(0, ('DEM3', 'DEM3[other]'), [])
        result.insert(0, ('IMP3', 'IMP3[other]'), [])
        result.insert(0, ('IMP3', 'IMP3[othercomment]'), [])
        return result
